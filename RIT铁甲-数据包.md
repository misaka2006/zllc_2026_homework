# 串口通信数据包格式

## 上位机向下位机发送

### 控制车身速度

数据包大小为14字节

第1字节：帧头，固定为`0x11`

第2-5字节：机器人前后移动速度，前进为正，单位：m/s。类型为`float`。

第6-9字节：机器人左右移动速度，左移为正，单位：m/s。类型为`float`。

第10-13字节：机器人绕 O 点旋转速度，逆时针为正，单位：rad/s。类型为`float`。

第14字节：CRC校验值。

### 控制舵机角度

数据包大小为6字节。

第1字节：帧头，固定为`0x12`。

第2字节：1号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第3字节：2号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第4字节：3号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第5字节：4号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第6字节：CRC校验值。

### 简化操作

#### 控制车直线运动方向

数据包大小为4字节

第1字节：帧头，固定为`0x14`。

第2-3字节：车身所要运动的方向的角度，角度以车中心为原点，正右方向为x轴，正前方向为y轴的坐标系中为参考。单位：度。类型为`int16_t`

第4字节：CRC校验值。

#### 控制车旋转方向

数据包大小为3字节

第1字节：帧头：固定为`0x15`

第2字节：运动的方向。值为1时是顺时针，值为2时为逆时针。类型为`uint8_t`

第3字节：CRC校验值

#### 选择车运动速度挡位

数据包大小为3字节

第1字节：帧头：固定为`0x16`

第2字节：选择的挡位，范围为0-3。0为停车，1为低速，2为中速，3为高速。类型为`uint8_t`

第3字节：CRC校验值

## 下位机向上位机发送

### 车身状态

数据包大小为18字节

第1字节：帧头，固定为`0x13`。

第2-5字节：机器人实际前后移动速度，前进为正，单位：m/s。类型为`float`。

第6-9字节：机器人实际左右移动速度，左移为正，单位：m/s。类型为`float`。

第10-13字节：机器人实际绕 O 点旋转速度，逆时针为正，单位：rad/s。类型为`float`。

第14字节：1号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第15字节：2号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第16字节：3号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第17字节：4号舵机的角度，有效值为0-180，大于180时视同180，单位：度。类型为`uint8_t`。

第18字节：CRC校验值。

## CRC校验算法

数据包的最后一位均采用CRC8校验，多项式为`0x1D (x^8 + x^5 + x^4 + x^3 + x^2 + 1)`。

校验时，除了校验位本身外，校验位前的所有数据均需参与校验过程。

C语言代码如下：

```c
// crc.h
#ifndef __CRC_H
#define __CRC_H

#include "main.h"

// 定义CRC8多项式（Polynomial）。
// 例如：0x1D (x^8 + x^5 + x^4 + x^3 + x^2 + 1) 是一个常见的多项式。
#define CRC8_POLYNOMIAL 0x1D

// 定义初始值（Initial value）。
// 常见的初始值有 0x00 或 0xFF。
// 某些协议可能要求在计算前对数据或结果进行异或操作（XOR）。
#define CRC8_INITIAL_VALUE 0x00

void crc8_init_table();
uint8_t crc8_table_driven(const uint8_t *data, size_t length);

#endif // !__CRC_H

// crc.c
#include "crc.h"

uint8_t crc8_table[256];

// 预先计算CRC8查找表
void crc8_init_table()
{
    uint16_t i, j;
    uint8_t crc;

    for (i = 0; i < 256; i++) {
        crc = (uint8_t)i;
        for (j = 0; j < 8; j++) {
            if (crc & 0x80) {
                // 这里的处理逻辑与直接计算法类似，但更简洁
                crc = (crc << 1) ^ CRC8_POLYNOMIAL;
            } else {
                crc <<= 1;
            }
        }
        crc8_table[i] = crc;
    }
}

// 使用查找表计算CRC8
uint8_t crc8_table_driven(const uint8_t *data, size_t length)
{
    uint8_t crc = CRC8_INITIAL_VALUE;
    size_t i;

    // 假设 crc8_init_table() 已经在程序开始时调用
    for (i = 0; i < length; i++) {
        // 使用当前CRC的高位（前一个字节计算的结果）和下一个数据字节来查找表
        // 索引 = 当前CRC ^ 当前数据字节
        crc = crc8_table[crc ^ data[i]];
    }

    // 假设不需要额外的 XOR_OUT 操作
    return crc;
}
```

使用时需要先调用`void crc8_init_()`函数进行初始化，调用一次即可，此后无需再次调用。

其后只需调用`uint8_t crc8_table_driven(const uint8_t *data, size_t length)`函数，传入需要校验的数据和参与校验的位数即可得到校验值。

# 
